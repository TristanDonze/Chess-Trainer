<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../css/global.css">
    <link rel="stylesheet" href="../css/chess.css">
    <link rel="stylesheet" href="../css/chess-page.css">


    <script src="../js/toolbox/toolbox.bundle.js"></script>
    <script src="../js/message.js"></script>
    <script src="../js/interface.js"></script>
    <script src="../js/d3.v7.min.js"></script>
    <script src="../js/chess_func.js"></script>

    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&" as="style" onload="this.onload=null;this.rel='stylesheet'">

</head>
<body>
    <main>
        <nav>
            <a href="home.html" class="nav-link material-symbols-outlined">home</a>
            <a href="chess.html" class="nav-link material-symbols-outlined current">chess</a>
            <a href="profil.html" class="nav-link material-symbols-outlined">person</a>
            <a href="theory.html" class="nav-link material-symbols-outlined">book</a>
        </nav>

        <div class="page-wrapper">
            <div class="chessboard-wrapper">
                <div class="actions">
                    <button class="material-symbols-outlined" title="Training game" onclick="start_training_game()">school</button>
                    <button class="material-symbols-outlined" title="Game analysis" onclick="find_game_to_analyze()">analytics</button>
                    <button class="material-symbols-outlined" title="Lecon with puzzles">lightbulb</button>
                </div>
                <svg id="board">
                </svg>

                <div class="game-tools">
                    <button class="material-symbols-outlined" title="Previous move" onclick="previous_move()">skip_previous</button>
                    <button class="material-symbols-outlined" title="Next move" onclick="next_move()">skip_next</button>
                    <button class="material-symbols-outlined" title="Auto play" onclick="start_auto_play()">play_circle</button>
                    <button class="material-symbols-outlined" title="Pause auto play" onclick="pause_auto_play()">pause_circle</button>
                    <button class="material-symbols-outlined" title="Reset board" onclick="restart_game()">restart_alt</button>
                </div>
            </div>

            <div class="interaction-wrapper">
                <div class="avatar-wrapper"></div>
                <div class="chatbox-wrapper">
                    <div class="messages-wrapper">
                        <!-- messages -->
                    </div>
                    <span class="next btn" onclick="continue_game_analysis(true)">Next</span>
                    <div class="actions-wrapper">
                        <div class="send-message-wrapper">
                            <input type="text" placeholder="Type your message...">
                            <button class="send-button material-symbols-outlined" onclick="send_chat_to_ai(this.parentElement)">send</button>
                        </div>
                        
                        <div class="switch-wrapper">
                            <span class="switch-to-text material-symbols-outlined" title="Switch to text mode">keyboard</span>
                            <span class="switch-to-audio material-symbols-outlined" title="Switch to audio mode">keyboard_voice</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

<script>
    let games_to_analyze = [];
    let current_game = null;
    let current_move_idx = 0;
    let current_turn = 'white';
    let is_game_analysis = false;
    let chat_analysis_context = null;
    let auto_play_interval = null;

    const messagesWrapper = document.querySelector('.messages-wrapper');
    const audioToggleText = document.querySelector('.switch-to-text');
    const audioToggleAudio = document.querySelector('.switch-to-audio');
    const commentaryHistory = [];
    let commentaryAudioEnabled = true;
    let commentaryAudioPlayer = null;

    const nextButton = document.querySelector('.next.btn');

    function setNextButtonVisible(visible) {
        if (!nextButton) return;
        nextButton.style.display = visible ? '' : 'none';
    }

    setNextButtonVisible(false);

    function setCommentaryAudio(enabled) {
        commentaryAudioEnabled = enabled;
        if (audioToggleText) {
            audioToggleText.classList.toggle('active', !enabled);
        }
        if (audioToggleAudio) {
            audioToggleAudio.classList.toggle('active', enabled);
        }
        if (!enabled && commentaryAudioPlayer) {
            commentaryAudioPlayer.pause();
            commentaryAudioPlayer = null;
        }
    }

    if (audioToggleText) {
        audioToggleText.addEventListener('click', () => setCommentaryAudio(false));
    }
    if (audioToggleAudio) {
        audioToggleAudio.addEventListener('click', () => setCommentaryAudio(true));
        audioToggleAudio.classList.add('active');
    }

    function handle_game_commentary(payload) {
        if (!payload) return;
        const container = messagesWrapper || document.querySelector('.messages-wrapper');
        if (!container) return;

        commentaryHistory.push(payload);
        while (commentaryHistory.length > 30) commentaryHistory.shift();

        const entry = document.createElement('div');
        entry.className = `commentary-entry severity-${payload.severity || 'correct'}`;

        const heading = document.createElement('div');
        heading.className = 'commentary-heading';
        if (!payload.show_recommendation && payload.actual_is_best) {
            heading.textContent = 'Best Move';
            heading.classList.add('best-move');
        } else {
            heading.textContent = payload.severity_label || 'Move feedback';
        }

        const moveSpan = document.createElement('span');
        moveSpan.className = 'move';
        const colorText = payload.player_color === 'black' ? 'Black' : 'White';
        const moveLabel = payload.move?.san || payload.move?.uci || '';
        moveSpan.textContent = `${colorText}: ${moveLabel}`;
        heading.appendChild(moveSpan);
        entry.appendChild(heading);

        const meta = document.createElement('div');
        meta.className = 'commentary-meta';
        const deltaRaw = Number(payload.evaluation?.player_delta_pawns);
        const delta = Number.isFinite(deltaRaw) ? deltaRaw : 0;
        const deltaText = `${delta >= 0 ? '+' : ''}${delta.toFixed(2)} pawns`;

        const afterCpRaw = Number(payload.evaluation?.player_score_after_cp);
        const evalAfterText = Number.isFinite(afterCpRaw)
            ? `${afterCpRaw >= 0 ? '+' : ''}${(afterCpRaw / 100).toFixed(2)} for ${colorText}`
            : `${payload.evaluation?.player_score_after_display || '+0.00'} for ${colorText}`;

        meta.innerHTML = `<span>Δ ${deltaText}</span><span>Eval now ${evalAfterText}</span>`;

        if (payload.best_move_summary && payload.best_move && !payload.actual_is_best) {
            const bestLabel = payload.best_move.san || payload.best_move.uci;
            meta.innerHTML += `<span>Best: ${bestLabel} (${payload.best_move_summary})</span>`;
        }

        const ts = payload.timestamp ? new Date(payload.timestamp * 1000) : new Date();
        meta.innerHTML += `<span class="timestamp">${ts.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>`;
        entry.appendChild(meta);

        const comment = document.createElement('p');
        comment.className = 'commentary-text';
        comment.textContent = payload.comment || '';
        entry.appendChild(comment);

        clear_advice_move();

        if (payload.recommendation && payload.show_recommendation && payload.recommendation.from && payload.recommendation.to) {
            const suggestion = document.createElement('div');
            suggestion.className = 'commentary-recommendation';

            const icon = document.createElement('span');
            icon.className = 'material-symbols-outlined';
            icon.textContent = 'north_east';
            suggestion.appendChild(icon);

            const recommendationMove = payload.best_move?.san || payload.recommendation.uci;
            suggestion.append(`Consider ${recommendationMove} in similar positions.`);
            entry.appendChild(suggestion);
        }

        container.appendChild(entry);
        while (container.childElementCount > 15) {
            container.removeChild(container.firstElementChild);
        }
        container.scrollTop = container.scrollHeight;

        if (payload.audio && payload.audio.b64 && commentaryAudioEnabled) {
            const mime = payload.audio.mime || 'audio/mpeg';
            const src = `data:${mime};base64,${payload.audio.b64}`;
            try {
                if (commentaryAudioPlayer) {
                    commentaryAudioPlayer.pause();
                }
                commentaryAudioPlayer = new Audio(src);
                commentaryAudioPlayer.play().catch(() => {});
            } catch (error) {
                console.error('Unable to play commentary audio', error);
            }
        }
    }

    window.handle_game_commentary = handle_game_commentary;

    function start_training_game() {
        const svg = d3.select("#board");
        svg.selectAll("*").remove();
        svg.classed("active", true);
        setNextButtonVisible(false);
        // draw_game("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
        // update_game_state("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
        // new Audio('../media/game-start.mp3').play();
        send_message("start-game", {"player1": "Player", "player2": "Trainer"});
    }

    function find_game_to_analyze() {
        send_message("get-chesscom-profil", {}, true, "Loading profil...");

        wait_for_message("chesscom-profil", timeout=5000, only_content=true).then((data) => {
            if (data === null) {
                Toast.error("Failed to load profil from Chess.com.");
                return; // Timeout: error will be return by the server
            }
            console.log("-->", data);
            LoadingScreen.hide();

            const escapeHTML = (s) =>
                String(s ?? '')
                    .replace(/&/g, '&amp;').replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;').replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');

            const fmtDateTime = (tsSec) => {
                if (!Number.isFinite(tsSec)) return '';
                const d = new Date(tsSec * 1000);
                return d.toLocaleString(undefined, {
                    day: '2-digit', month: 'short', year: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });
            };

            // Normalize UI score; treat castling ("0-0"/"O-O") as not a result.
            // UI convention: draw/unknown => "0 - 0".
            const normalizeResultUI = (raw, win) => {
                const r = (raw || '').trim();
                if (r === '1-0') return '1 - 0';
                if (r === '0-1') return '0 - 1';
                if (r === '1/2-1/2' || r === '½-½') return '0 - 0';
                if (r === '0-0' || /^O[-–]O$/.test(r)) return '0 - 0';
                if (win === 'white') return '1 - 0';
                if (win === 'black') return '0 - 1';
                if (win === 'draw')  return '0 - 0';
                return '0 - 0';
            };

            const winnerSide = (g) => {
                const r = (g.result || '').trim();
                if (r === '1-0') return 'white';
                if (r === '0-1') return 'black';
                if (r === '1/2-1/2' || r === '½-½') return 'draw';
                if (g.white?.result === 'win') return 'white';
                if (g.black?.result === 'win') return 'black';
                if (g.white?.result === 'agreed' && g.black?.result === 'agreed') return 'draw';
                return null;
            };

            // Counts moves from PGN (plies/2), ignoring headers/comments/NAGs/results.
            const countMovesFromPGN = (pgn) => {
                if (!pgn || typeof pgn !== 'string') return null;
                let t = pgn.replace(/\r/g, '');
                t = t.replace(/^\s*\[.*?\]\s*$/gm, '');        // headers
                t = t.replace(/\{[^}]*\}/g, '').replace(/\([^)]*\)/g, ''); // comments/vars
                t = t.replace(/\$\d+/g, '');                   // NAGs
                t = t.replace(/\b\d+\.(\.\.)?/g, '');          // move numbers
                const tokens = t.trim().split(/\s+/).filter(Boolean)
                    .filter(tok => !/^(1-0|0-1|1\/2-1\/2|½-½|0-0|O-O|O–O)$/.test(tok));
                const plies = tokens.length;
                if (!plies) return null;
                return Math.ceil(plies / 2);
            };

            games_to_analyze = data.games || [];

            const gameHistoryHTML = (data.games || []).map((game, idx) => {
                const white = game.white || {};
                const black = game.black || {};
                const win = winnerSide(game);
                const scoreText = normalizeResultUI(game.result, win);
                const moves = countMovesFromPGN(game.pgn);

                const wClass = win === 'white' ? 'winner' : (win === 'draw' ? 'draw' : 'loser');
                const bClass = win === 'black' ? 'winner' : (win === 'draw' ? 'draw' : 'loser');

                return `
                <a class="game-block" onclick='analyze_game(${idx})'>
                <div class="score">${scoreText}</div>
                <div class="players">
                    <div class="player white ${wClass}">
                    <span class="result-dot"></span>
                    <span class="name">${escapeHTML(white.username ?? '—')}</span>
                    <span class="rating">(${escapeHTML(white.rating ?? '—')})</span>
                    </div>
                    <div class="player black ${bClass}">
                    <span class="result-dot"></span>
                    <span class="name">${escapeHTML(black.username ?? '—')}</span>
                    <span class="rating">(${escapeHTML(black.rating ?? '—')})</span>
                    </div>
                </div>
                <div class="meta">
                    <span class="date">${game.end_time ? escapeHTML(fmtDateTime(game.end_time)) : ''}</span>
                    ${moves != null ? `<span class="moves">${moves} moves</span>` : ''}
                </div>
                </a>`.trim();
            }).join('');


            const box = document.createElement('div');
            box.innerHTML = `
                <h3>Choose a game to analyze</h3>

                <div class="games-wrapper">
                    ${gameHistoryHTML || '<i>No games found.</i>'}
                </div>
            `;

            new PopUp({
                content: box,
                buttons: [
                    { label: 'Cancel', class_name: 'no-button' },
                ]
            }).open();
        });
    }

    function analyze_game(idx) {
        if (idx < 0 || idx >= games_to_analyze.length) {
            Toast.error("Invalid game index.");
            return;
        }
        const game = games_to_analyze[idx];
        d3.select(".pop-up-wrapper").remove();
        console.log("Analyzing game:", game);

        const svg = d3.select("#board");
        svg.selectAll("*").remove();
        svg.classed("active", true);
        draw_game("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
        new Audio('../media/game-start.mp3').play();
        is_game_analysis = true;
        send_message("analyze-game", {game: game}, true, "Loading game...");
        wait_for_message("game-analyzed", timeout=50000, only_content=true).then((data) => {
            if (data === null) {
                Toast.error("Failed to load game for analysis.");
                return; // Timeout: error will be return by the server
            }
            console.log("Game loaded:", data);
            current_game = data;
            
            start_game_analysis()
            // move_idx = 0;
            // current_turn = 'white';
            // draw_game(data.moves[current_turn][move_idx].fen);
            // while (data.moves[current_turn]?.length > move_idx) {
            //     console.log("Playing move:", data.moves[current_turn][move_idx]);
            //     move_idx++;
            //     current_turn = current_turn === 'white' ? 'black' : 'white';
            // }
            // move_idx--;
            // current_turn = current_turn === 'white' ? 'black' : 'white';

            // draw_game(data.moves[current_turn][move_idx].fen);
        });
    }

    async function start_game_analysis() {
        if (!is_game_analysis || !current_game) return;
        setNextButtonVisible(true);
        chat_clear_messages();
        chat_send_message("Let's analyze this game together!", "assistant");
        move_idx = 0;
        current_turn = 'white';

        continue_game_analysis(false);
    }

    async function continue_game_analysis(pass_first_move=true) {
        if (!is_game_analysis || !current_game) return;

        if (pass_first_move) {
            next_move();
            next_move();
        }

        timeout = 320;
        while (current_game.moves[current_turn]?.length > current_move_idx && !current_game.moves[current_turn][current_move_idx].key_move) {
            await new Promise(r => setTimeout(r, timeout));
            timeout = timeout > 20 ? timeout - 20 : 20;
            next_move();
        }
        if (current_game.moves[current_turn][current_move_idx] === undefined) {
            // end of game
            clearInterval(auto_play_interval);
            await new Promise(r => setTimeout(r, 200));
            chat_send_message("The game analysis is complete. Well played!", "assistant");
            auto_play_interval = null;
            setNextButtonVisible(false);
            return;
        }
        let comment = current_game.moves[current_turn][current_move_idx].comment
        let audio = current_game.moves[current_turn][current_move_idx].audio
        if (!pass_first_move) previous_move();

        chat_send_message("Let's discuss about this position.", "assistant");
        chat_send_message(
            comment || "No commentary available for this move.",
            "assistant"
        );
        
        // Play TTS audio if available and audio is enabled
        if (audio && audio.b64 && commentaryAudioEnabled) {
            const mime = audio.mime || 'audio/mpeg';
            const src = `data:${mime};base64,${audio.b64}`;
            try {
                if (commentaryAudioPlayer) {
                    commentaryAudioPlayer.pause();
                }
                commentaryAudioPlayer = new Audio(src);
                commentaryAudioPlayer.play().catch((error) => {
                    console.error('Unable to play TTS audio during analysis', error);
                });
            } catch (error) {
                console.error('Error creating TTS audio during analysis', error);
            }
        }
    }

    function send_chat_to_ai(messageElement) {
        if (!is_game_analysis || !current_game) return;
        if (!messageElement) return;
        if (!messageElement.querySelector("input")) return;
        if (!messageElement.querySelector("input").value) return;
        if (messageElement.querySelector("input").value.trim() === "") return;

        const message = messageElement.querySelector("input").value;
        if (!message) return;

        chat_send_message(message, "user");
        messageElement.querySelector("input").value = "";

        send_message("send-analysis-chat", {message: message, context: chat_analysis_context})
        wait_for_message("analysis-chat-response", timeout=30000, only_content=true).then((data) => {
            if (data === null) {
                Toast.error("No response from analysis chat.");
                return; // Timeout: error will be return by the server
            }
            console.log("Chat response:", data);
            chat_send_message(data.text || "No response.", "assistant");

            if (data.audio && data.audio.b64 && commentaryAudioEnabled) {
                const mime = data.audio.mime || 'audio/mpeg';
                const src = `data:${mime};base64,${data.audio.b64}`;
                try {
                    if (commentaryAudioPlayer) {
                        commentaryAudioPlayer.pause();
                    }
                    commentaryAudioPlayer = new Audio(src);
                    commentaryAudioPlayer.play().catch((error) => {
                        console.error('Unable to play chat TTS audio during analysis', error);
                    });
                } catch (error) {
                    console.error('Error creating chat TTS audio during analysis', error);
                }
            }
        });
    }

    function next_move() {
        if (!is_game_analysis || !current_game) {
            // end game sound + clear interval
            new Audio('../media/game-end.webm').play();
            clearInterval(auto_play_interval);
            auto_play_interval = null;
            return;
        }
        if (current_game.moves[current_turn]?.length > current_move_idx) {
            board = d3.select("#board");
            board.selectAll("rect").classed("moved", false);

            move_from_square = current_game.moves[current_turn][current_move_idx].from;
            move_to_square = current_game.moves[current_turn][current_move_idx].to;
            promote_to = current_game.moves[current_turn][current_move_idx].promote;
            rect_from = board.select(`rect#${move_from_square}`)
            rect_to = board.select(`rect#${move_to_square}`)

            // check if to_square is occupied (to play capture sound)
            piece_at_to = d3.select(`g#board-pieces g[pos="${move_to_square}"]`);
            if (piece_at_to.size() > 0) {
                new Audio('../media/capture.mp3').play();
            } else {
                // check if it's a castling
                if (promote_to) {
                    new Audio('../media/promotion.mp3').play();
                } else if (Math.abs(move_from_square.charCodeAt(0) - move_to_square.charCodeAt(0)) === 2 && current_game.moves[current_turn][current_move_idx].piece.toLowerCase() === 'k') {
                    new Audio('../media/castle.mp3').play();
                } else {
                    new Audio('../media/move.mp3').play();
                }
            }

            draw_from_fen(current_game.moves[current_turn][current_move_idx].fen);

            if (current_game.moves[current_turn][current_move_idx].king_in_check) {
                new Audio('../media/move-check.mp3').play();
            }
            rect_from.classed("moved", true);
            rect_to.classed("moved", true);
            
            // if last move, stroke kings (no more moves from this color)
            
            last_turn = current_turn + "";
            last_move_idx = current_move_idx + 0
            current_turn = current_turn === 'white' ? 'black' : 'white';
            if (current_turn === 'white') {
                current_move_idx++;
            }

            if (
                (current_turn === 'white' && current_game.moves['black']?.length <= current_move_idx) ||
                (current_turn === 'black' && current_game.moves['white']?.length <= current_move_idx)
            ) {
                // end of game
                clearInterval(auto_play_interval);
                auto_play_interval = null;
                
                new Audio('../media/game-end.webm').play();
                winning_side = last_turn === 'white' ? current_game.moves['black'][last_move_idx].winner : current_game.moves['white'][last_move_idx].winner;
                console.log("Game ended. Winning side:", winning_side);

                if (winning_side) {
                    const loosing_king = d3.select(`g#board-pieces g[fen="${winning_side === "white" ? "k" : "K"}"]`);
                    const winning_king = d3.select(`g#board-pieces g[fen="${winning_side === "white" ? "K" : "k"}"]`);
                    const loosing_king_square = d3.select(`rect#${loosing_king.attr("pos")}`);
                    const winning_king_square = d3.select(`rect#${winning_king.attr("pos")}`); 
                    loosing_king_square.attr("stroke", "red").attr("stroke-width", 4);
                    winning_king_square.attr("stroke", "green").attr("stroke-width", 4);
                } else if (current_game.moves[last_turn][last_move_idx].draw) {
                    // if draw, stroke both kings in yellow
                    const white_king = d3.select(`g#board-pieces g[fen="K"]`);
                    const black_king = d3.select(`g#board-pieces g[fen="k"]`);
                    const white_king_square = d3.select(`rect#${white_king.attr("pos")}`);
                    const black_king_square = d3.select(`rect#${black_king.attr("pos")}`); 
                    white_king_square.attr("stroke", "orange").attr("stroke-width", 4);
                    black_king_square.attr("stroke", "orange").attr("stroke-width", 4);
                } else {
                    // else stroke both kings in blue (no checkmate)
                    const white_king = d3.select(`g#board-pieces g[fen="K"]`);
                    const black_king = d3.select(`g#board-pieces g[fen="k"]`);
                    const white_king_square = d3.select(`rect#${white_king.attr("pos")}`);
                    const black_king_square = d3.select(`rect#${black_king.attr("pos")}`); 
                    white_king_square.attr("stroke", "blue").attr("stroke-width", 4);
                    black_king_square.attr("stroke", "blue").attr("stroke-width", 4);
                }
            }
        }
    }

    function previous_move() {
        if (!is_game_analysis || !current_game) return;

        // clear interval if any
        clearInterval(auto_play_interval);
        auto_play_interval = null;
        const whites = current_game.moves?.white || [];
        const blacks = current_game.moves?.black || [];

        if (current_turn === 'white') {
            const idx = current_move_idx - 1;
            if (idx < 0 || !whites[idx]) {
                start_fen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
                draw_from_fen(start_fen);
                d3.select("#board").selectAll("rect").classed("moved", false);
                current_turn = 'white';
                current_move_idx = 0;
                return;
            }
            const mv = whites[idx];
            draw_from_fen(mv.fen);

            const board = d3.select("#board");
            board.selectAll("rect").classed("moved", false);
            board.select(`rect#${mv.from}`).classed("moved", true);
            board.select(`rect#${mv.to}`).classed("moved", true);

            current_turn = 'black';
            current_move_idx = idx; // k-1
        } else { // current_turn === 'black'
            const prevIdx = current_move_idx - 1;
            if (prevIdx < 0 || !blacks[prevIdx]) {
                start_fen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
                draw_from_fen(start_fen);
                d3.select("#board").selectAll("rect").classed("moved", false);
                current_turn = 'white';
                current_move_idx = 0;
                return;
            }
            const mv = blacks[prevIdx];
            draw_from_fen(mv.fen);

            const board = d3.select("#board");
            board.selectAll("rect").classed("moved", false);
            board.select(`rect#${mv.from}`).classed("moved", true);
            board.select(`rect#${mv.to}`).classed("moved", true);

            current_turn = 'white';
            current_move_idx = prevIdx + 1; // redevient k
        }
    }

    function restart_game() {
        start_fen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
        draw_from_fen(start_fen);
        d3.select("#board").selectAll("rect").classed("moved", false);
        current_turn = 'white';
        current_move_idx = 0;
    }

    function start_auto_play() {
        if (!is_game_analysis || !current_game || auto_play_interval) return;
        auto_play_interval = setInterval(() => {
            next_move();
        }, 800);
    }

    function pause_auto_play() {
        clearInterval(auto_play_interval);
        auto_play_interval = null;
    }

    function chat_send_message(msg) {
        const wrapper = document.createElement('div');
        wrapper.className = 'message message--assistant';

        // Bubble container
        const bubble = document.createElement('div');
        bubble.className = 'message__bubble';

        // Text node
        const text = document.createElement('div');
        text.className = 'message__text';
        text.textContent = msg;

        // Nest the elements
        bubble.appendChild(text);
        wrapper.appendChild(bubble);

        document.querySelector('.messages-wrapper').appendChild(wrapper);
    }

    chat_clear_messages = () => {
        const container = document.querySelector('.messages-wrapper');
        if (container) {
            container.innerHTML = '';
        }
    }

</script>
</body>
</html>
